

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Functions &mdash; PsyNeuLink 0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="PsyNeuLink 0.1 documentation" href="index.html"/>
        <link rel="next" title="Run" href="Run.html"/>
        <link rel="prev" title="LearningProjection" href="LearningProjection.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PsyNeuLink
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="System.html">System</a></li>
<li class="toctree-l1"><a class="reference internal" href="Process.html">Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="Mechanism.html">Mechanisms</a></li>
<li class="toctree-l1"><a class="reference internal" href="State.html">States</a></li>
<li class="toctree-l1"><a class="reference internal" href="Projection.html">Projections</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Functions</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Run.html">Run</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">PsyNeuLink</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Functions</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/Function.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="functions">
<h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<span class="target" id="module-Function"></span><dl class="docutils">
<dt>Example function:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Contradiction" title="Function.Contradiction"><code class="xref py py-class docutils literal"><span class="pre">Contradiction</span></code></a></li>
</ul>
</dd>
<dt>Combination Components:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.LinearCombination" title="Function.LinearCombination"><code class="xref py py-class docutils literal"><span class="pre">LinearCombination</span></code></a></li>
</ul>
</dd>
<dt>TransferMechanism Components:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Linear" title="Function.Linear"><code class="xref py py-class docutils literal"><span class="pre">Linear</span></code></a></li>
<li><a class="reference internal" href="#Function.Exponential" title="Function.Exponential"><code class="xref py py-class docutils literal"><span class="pre">Exponential</span></code></a></li>
<li><a class="reference internal" href="#Function.Logistic" title="Function.Logistic"><code class="xref py py-class docutils literal"><span class="pre">Logistic</span></code></a></li>
<li><a class="reference internal" href="#Function.SoftMax" title="Function.SoftMax"><code class="xref py py-class docutils literal"><span class="pre">SoftMax</span></code></a></li>
<li><a class="reference internal" href="#Function.LinearMatrix" title="Function.LinearMatrix"><code class="xref py py-class docutils literal"><span class="pre">LinearMatrix</span></code></a></li>
</ul>
</dd>
<dt>Integrator Components:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Integrator" title="Function.Integrator"><code class="xref py py-class docutils literal"><span class="pre">Integrator</span></code></a></li>
<li><a class="reference internal" href="#Function.BogaczEtAl" title="Function.BogaczEtAl"><code class="xref py py-class docutils literal"><span class="pre">BogaczEtAl</span></code></a></li>
<li><a class="reference internal" href="#Function.NavarroAndFuss" title="Function.NavarroAndFuss"><code class="xref py py-class docutils literal"><span class="pre">NavarroAndFuss</span></code></a></li>
</ul>
</dd>
<dt>Learning Components:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Reinforcement" title="Function.Reinforcement"><code class="xref py py-class docutils literal"><span class="pre">Reinforcement</span></code></a></li>
<li><a class="reference internal" href="#Function.BackPropagation" title="Function.BackPropagation"><code class="xref py py-class docutils literal"><span class="pre">BackPropagation</span></code></a></li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="Function.Contradiction">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Contradiction</code><span class="sig-paren">(</span><em>variable_default=0</em>, <em>params=None</em>, <em>prefs: &lt;function is_pref_set at 0x109989488&gt; = None</em>, <em>context='Contradiction INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Contradiction" title="Permalink to this definition">¶</a></dt>
<dd><p>Example function for use as template for function construction</p>
<dl class="docutils">
<dt>Iniialization arguments:</dt>
<dd><ul class="first last">
<li><p class="first">variable (boolean or statement resolving to boolean)</p>
</li>
<li><dl class="first docutils">
<dt>params (dict) specifying the:</dt>
<dd><ul class="first last simple">
<li>propensity (kwPropensity: a mode specifying the manner of responses (tendency to agree or disagree)</li>
<li>pertinacity (kwPertinacity: the consistency with which the manner complies with the propensity</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Contradiction.function returns <code class="xref std std-keyword docutils literal"><span class="pre">True</span></code> or <code class="xref std std-keyword docutils literal"><span class="pre">False</span></code></p>
<dl class="class">
<dt id="Function.Contradiction.Manner">
<em class="property">class </em><code class="descname">Manner</code><a class="headerlink" href="#Function.Contradiction.Manner" title="Permalink to this definition">¶</a></dt>
<dd><p>An enumeration.</p>
</dd></dl>

<dl class="method">
<dt id="Function.Contradiction.function">
<code class="descclassname">Contradiction.</code><code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Contradiction.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean that is (or tends to be) the same as or opposite the one passed in</p>
<p>Returns <code class="xref std std-keyword docutils literal"><span class="pre">True</span></code> or <code class="xref std std-keyword docutils literal"><span class="pre">False</span></code>, that is either the same or opposite the statement passed in as the
variable
The propensity parameter must be set to be Manner.OBSEQUIOUS or Manner.CONTRARIAN, which</p>
<blockquote>
<div>determines whether the response is (or tends to be) the same as or opposite to the statement</div></blockquote>
<p>The pertinacity parameter determines the consistency with which the response conforms to the manner</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> &#8211; (boolean) Statement to probe</li>
<li><strong>params</strong> &#8211; (dict) with entires specifying
kwPropensity: Contradiction.Manner - contrarian or obsequious (default: CONTRARIAN)
kwPertinacity: float - obstinate or equivocal (default: 10)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return response:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">(boolean)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.LinearCombination">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">LinearCombination</code><span class="sig-paren">(</span><em>variable_default=[2, 2], scale: &lt;function parameter_spec at 0x10a6a5048&gt; = 1.0, offset: &lt;function parameter_spec at 0x10a6a5048&gt; = 0.0, exponents: &lt;function is_numeric_or_none at 0x10990e8c8&gt; = None, weights: &lt;function is_numeric_or_none at 0x10990e8c8&gt; = None, operation: &lt;typecheck.tc_predicates.enum object at 0x10a58e710&gt; = 'sum', params=None, prefs: &lt;function is_pref_set at 0x109989488&gt; = None, context='LinearCombination INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearCombination" title="Permalink to this definition">¶</a></dt>
<dd><p>Linearly combine arrays of values with optional weighting, offset, and/or scaling</p>
<dl class="docutils">
<dt>Description:</dt>
<dd><p class="first">Combine corresponding elements of arrays in variable arg, using arithmetic operation determined by OPERATION
Use optional WEIGHTING argument to weight contribution of each array to the combination
Use optional SCALE and OFFSET parameters to linearly transform the resulting array
Returns a list or 1D array of the same length as the individual ones in the variable</p>
<p>Notes:
* If variable contains only a single array, it is simply linearly transformed using SCALE and OFFSET
* If there is more than one array in variable, they must all be of the same length
* WEIGHTS can be:</p>
<blockquote class="last">
<div><ul class="simple">
<li>1D: each array in the variable is scaled by the corresponding element of WEIGHTS)</li>
<li>2D: each array in the variable is multiplied by (Hadamard Product) the corresponding array in kwWeight</li>
</ul>
</div></blockquote>
</dd>
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>variable (value, np.ndarray or list): values to be combined;</dt>
<dd><p class="first last">can be a list of lists, or a 1D or 2D np.array;  a 1D np.array is always returned
if it is a list, it must be a list of numbers, lists, or np.arrays
all items in the list or 2D np.array must be of equal length
the length of WEIGHTS (if provided) must equal the number of arrays (2nd dimension; default is 2)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>params (dict) can include:</dt>
<dd><ul class="first last">
<li><p class="first">WEIGHTS (list of numbers or 1D np.array): multiplies each variable before combining them (default: [1, 1])</p>
</li>
<li><p class="first">OFFSET (value): added to the result (after the arithmetic operation is applied; default is 0)</p>
</li>
<li><p class="first">SCALE (value): multiples the result (after combining elements; default: 1)</p>
</li>
<li><dl class="first docutils">
<dt>OPERATION (Operation Enum) - method used to combine terms (default: SUM)</dt>
<dd><p class="first last">SUM: element-wise sum of the arrays in variable
PRODUCT: Hadamard Product of the arrays in variable</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>LinearCombination.function returns combined values:
- single number if variable was a single number
- list of numbers if variable was list of numbers
- 1D np.array if variable was a single np.variable or np.ndarray</p>
<dl class="method">
<dt id="Function.LinearCombination.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearCombination.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Linearly combine a list of values, and optionally offset and/or scale them</p>
<dl class="docutils">
<dt># DOCUMENT:</dt>
<dd><p class="first">Handles 1-D or 2-D arrays of numbers
Convert to np.array
All elements must be numeric
If linear (single number or 1-D array of numbers) just apply scale and offset
If 2D (array of arrays), apply exponents to each array
If 2D (array of arrays), apply weights to each array
Operators:  SUM AND PRODUCT
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
OLD:
Variable must be a list of items:</p>
<blockquote>
<div><ul class="simple">
<li>each item can be a number or a list of numbers</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Corresponding elements of each item in variable are combined based on OPERATION param:</dt>
<dd><ul class="first last simple">
<li>SUM adds corresponding elements</li>
<li>PRODUCT multiples corresponding elements</li>
</ul>
</dd>
<dt>An initializer (kwLinearCombinationInitializer) can be provided as the first item in variable;</dt>
<dd>it will be populated with a number of elements equal to the second item,
each element of which is determined by OPERATION param:
- for SUM, initializer will be a list of 0&#8217;s
- for PRODUCT, initializer will be a list of 1&#8217;s</dd>
<dt>Returns a list of the same length as the items in variable,</dt>
<dd>each of which is the combination of their corresponding elements specified by OPERATION</dd>
</dl>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">var variable:</th><td class="field-body">(list of numbers) - values to calculate (default: [0, 0]:</td>
</tr>
<tr class="field-even field"><th class="field-name">params:</th><td class="field-body">(dict) with entries specifying:
EXPONENTS (2D np.array): exponentiate each value in the variable array (default: none)
WEIGHTS (2D np.array): multiply each value in the variable array (default: none):
OFFSET (scalar) - additive constant (default: 0):
SCALE: (scalar) - scaling factor (default: 1)
OPERATION: LinearCombination.Operation - operation to perform (default: SUM):</td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">(1D np.array)</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Linear">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Linear</code><span class="sig-paren">(</span><em>variable_default=[0], slope: &lt;function parameter_spec at 0x10a6a5048&gt; = 1.0, intercept: &lt;function parameter_spec at 0x10a6a5048&gt; = 0.0, params=None, prefs: &lt;function is_pref_set at 0x109989488&gt; = None, context='Linear INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a linear transform of input variable (SLOPE, INTERCEPT)</p>
<dl class="docutils">
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><p class="first">variable (number): transformed by linear function: slope * variable + intercept</p>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifies</dt>
<dd><ul class="first last simple">
<li>slope (SLOPE: value) - slope (default: 1)</li>
<li>intercept (INTERCEPT: value) - intercept (defaul: 0)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Linear.function returns scalar result</p>
<dl class="method">
<dt id="Function.Linear.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Linear.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate single value (defined by slope and intercept)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="InputState.html#InputState.InputState.variable" title="InputState.InputState.variable"><strong>variable</strong></a> &#8211; (number) - value to be &#8220;plotted&#8221; (default: 0</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
SLOPE: number - slope (default: 1)
INTERCEPT: number - intercept (default: 0)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return number:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.Linear.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em>, <em>input=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Linear.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of the softMax sigmoid function</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Exponential">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Exponential</code><span class="sig-paren">(</span><em>variable_default=0</em>, <em>rate: &lt;function parameter_spec at 0x10a6a5048&gt; = 1.0</em>, <em>scale: &lt;function parameter_spec at 0x10a6a5048&gt; = 1.0</em>, <em>params=None</em>, <em>prefs: &lt;function is_pref_set at 0x109989488&gt; = None</em>, <em>context='Exponential INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate an exponential transform of input variable  (RATE, SCALE)</p>
<dl class="docutils">
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>variable (number):</dt>
<dd><ul class="first last simple">
<li>scalar value to be transformed by exponential function: scale * e**(rate * x)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifies</dt>
<dd><ul class="first last simple">
<li>rate (RATE: coeffiencent on variable in exponent (default: 1)</li>
<li>scale (SCALE: coefficient on exponential (default: 1)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Exponential.function returns scalar result</p>
<dl class="method">
<dt id="Function.Exponential.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Exponential.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="InputState.html#InputState.InputState.variable" title="InputState.InputState.variable"><strong>variable</strong></a> &#8211; (number) - value to be exponentiated (default: 0</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
RATE: number - rate (default: 1)
SCALE: number - scale (default: 1)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return number:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.Exponential.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em>, <em>input=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Exponential.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of the softMax sigmoid function</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Logistic">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Logistic</code><span class="sig-paren">(</span><em>variable_default=0</em>, <em>gain: &lt;function parameter_spec at 0x10a6a5048&gt; = 1.0</em>, <em>bias: &lt;function parameter_spec at 0x10a6a5048&gt; = 0.0</em>, <em>params=None</em>, <em>prefs: &lt;function is_pref_set at 0x109989488&gt; = None</em>, <em>context='Logistic Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Logistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the logistic transform of input variable  (GAIN, BIAS)</p>
<dl class="docutils">
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>variable (number):</dt>
<dd><ul class="first last simple">
<li>scalar value to be transformed by logistic function: 1 / (1 + e**(gain*variable + bias))</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifies</dt>
<dd><ul class="first last simple">
<li>gain (GAIN): coeffiencent on exponent (default: 1)</li>
<li>bias (BIAS): additive constant in exponent (default: 0)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Logistic.function returns scalar result</p>
<dl class="method">
<dt id="Function.Logistic.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Logistic.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Logistic sigmoid function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="InputState.html#InputState.InputState.variable" title="InputState.InputState.variable"><strong>variable</strong></a> &#8211; (number) - value to be transformed by logistic function (default: 0)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
GAIN: number - gain (default: 1)
BIAS: number - rate (default: 0)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return number:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.Logistic.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em>, <em>input=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Logistic.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of the logistic signmoid function</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.SoftMax">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">SoftMax</code><span class="sig-paren">(</span><em>variable_default=0</em>, <em>gain: &lt;function parameter_spec at 0x10a6a5048&gt; = 1.0</em>, <em>output: &lt;typecheck.tc_predicates.enum object at 0x10a58e358&gt; = 'all'</em>, <em>params: &lt;typecheck.framework.optional object at 0x10a58ebe0&gt; = None</em>, <em>prefs: &lt;function is_pref_set at 0x109989488&gt; = None</em>, <em>context='SoftMax Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SoftMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the softMax transform of input variable  (GAIN, BIAS)</p>
<dl class="docutils">
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>variable (number):</dt>
<dd><ul class="first last simple">
<li>scalar value to be transformed by softMax function: e**(gain * variable) / sum(e**(gain * variable))</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifies</dt>
<dd><ul class="first">
<li><p class="first">gain (GAIN): coeffiencent on exponent (default: 1)</p>
</li>
<li><dl class="first docutils">
<dt>output (OUTPUT_TYPE): determines how to populate the return array (default: ALL)</dt>
<dd><p class="first last">ALL: array each element of which is the softmax value of the elements in the input array
MAX_VAL: array with a scalar for the element with the maximum softmax value, and zeros elsewhere
MAX_INDICATOR: array with a one for the element with the maximum softmax value, and zeros elsewhere
PROB: probabilistially picks an element based on their softmax values to pass through; all others are zero</p>
</dd>
</dl>
</li>
</ul>
<p class="last"># + max (kwMax): only reports max value, all others set to 0 (default: <code class="xref std std-keyword docutils literal"><span class="pre">False</span></code>)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>SoftMax.function returns scalar result</p>
<dl class="method">
<dt id="Function.SoftMax.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SoftMax.function" title="Permalink to this definition">¶</a></dt>
<dd><p>SoftMax sigmoid function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="InputState.html#InputState.InputState.variable" title="InputState.InputState.variable"><strong>variable</strong></a> &#8211; (number) - value to be transformed by softMax function (default: 0)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
GAIN: number - gain (default: 1)
BIAS: number - rate (default: 0)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return number:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.SoftMax.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em>, <em>input=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SoftMax.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of the softMax sigmoid function</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.LinearMatrix">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">LinearMatrix</code><span class="sig-paren">(</span><em>variable_default=[0], matrix: &lt;function matrix_spec at 0x10a6a50d0&gt; = None, params=None, prefs: &lt;function is_pref_set at 0x109989488&gt; = None, context='Linear Matrix INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Map sender vector to receiver vector using a linear weight matrix  (kwReceiver, MATRIX)</p>
<p>Use a weight matrix to convert a sender vector into a receiver vector:
- each row of the mapping corresponds to an element of the sender vector (outer index)
- each column of the mapping corresponds to an element of the receiver vector (inner index):</p>
<p>Initialization arguments:
- variable (2D np.ndarray containing exactly two sub-arrays:  sender and receiver vectors
- params (dict) specifying:</p>
<blockquote>
<div><ul class="simple">
<li>filler (kwFillerValue: number) value used to initialize all entries in matrix (default: 0)</li>
<li>identity (kwkwIdentityMapping: boolean): constructs identity matrix (default: <code class="xref std std-keyword docutils literal"><span class="pre">False</span></code>)</li>
</ul>
</div></blockquote>
<p>Create a matrix in self.matrix that is used in calls to LinearMatrix.function.</p>
<p>Returns sender 2D array linearly transformed by self.matrix</p>
<dl class="method">
<dt id="Function.LinearMatrix.instantiate_matrix">
<code class="descname">instantiate_matrix</code><span class="sig-paren">(</span><em>specification</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearMatrix.instantiate_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements matrix indicated by specification</p>
<blockquote>
<div><p>Specification is derived from MATRIX param (passed to self.__init__ or self.function)</p>
<dl class="docutils">
<dt>Specification (validated in _validate_params):</dt>
<dd><ul class="first last simple">
<li>single number (used to fill self.matrix)</li>
<li>matrix keyword (see get_matrix)</li>
<li>2D list or np.ndarray of numbers</li>
</ul>
</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return matrix:</th><td class="field-body">(2D list)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.LinearMatrix.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearMatrix.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms variable vector using either self.matrix or specification in params</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="InputState.html#InputState.InputState.variable" title="InputState.InputState.variable"><strong>variable</strong></a> &#8211; (list) - vector of numbers with length equal of height (number of rows, inner index) of matrix</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; <p>(dict) with entries specifying:
MATRIX: value - used to override self.matrix implemented by __init__;  must be one of:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>2D matrix - two-item list, each of which is a list of numbers with</dt>
<dd>length that matches the length of the vector in variable</dd>
</dl>
</li>
<li>kwIdentity - specifies use of identity matrix (dimensions of vector)</li>
<li>number - used to fill matrix of same dimensions as self.matrix</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Return list of numbers:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">vector with length = width (number of columns, outer index) of matrix</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Integrator">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Integrator</code><span class="sig-paren">(</span><em>variable_default=None</em>, <em>rate: &lt;function parameter_spec at 0x10a6a5048&gt; = 1.0</em>, <em>weighting: &lt;typecheck.tc_predicates.enum object at 0x10a67e2b0&gt; = 'constant'</em>, <em>params: &lt;typecheck.framework.optional object at 0x10a67e358&gt; = None</em>, <em>prefs: &lt;function is_pref_set at 0x109989488&gt; = None</em>, <em>context='Integrator Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate an accumulated and/or time-averaged value for input variable using a specified accumulation method</p>
<dl class="docutils">
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><p class="first">variable: new input value, to be combined with old value at rate and using method specified by params</p>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifying:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>kwInitializer (value): initial value to which to set self.oldValue (default: variableClassDefault)</dt>
<dd><ul class="first simple">
<li>must be same type and format as variable</li>
<li>can be specified as a runtime parameter, which resets oldValue to one specified</li>
</ul>
<p class="last">Note: self.oldValue stores previous value with which new value is integrated</p>
</dd>
</dl>
</li>
<li><p class="first">RATE (value): rate of accumulation based on weighting of new vs. old value (default: 1)</p>
</li>
<li><dl class="first docutils">
<dt>WEIGHTING (Weightings Enum): method of accumulation (default: CONSTANT):</dt>
<dd><p class="first">CONSTANT &#8211; returns old_value incremented by rate parameter (ignores input)
SIMPLE&nbsp;&#8211; returns old_value incremented by rate * new_value
ADAPTIVE &#8211; returns rate-weighted average of old and new values  (Delta rule, Wiener filter)</p>
<blockquote class="last">
<div><p>rate = 0:  no change (returns old_value)
rate 1:    instantaneous change (returns new_value)</p>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Class attributes:
- oldValue (value): stores previous value with which value provided in variable is integrated</p>
<p>Integrator.function returns scalar result</p>
<dl class="method">
<dt id="Function.Integrator.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Integrator.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrator function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="InputState.html#InputState.InputState.variable" title="InputState.InputState.variable"><strong>variable</strong></a> &#8211; (list) - old_value and new_value (default: [0, 0]:</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
RATE: number - rate of accumulation as relative weighting of new vs. old value  (default = 1)
WEIGHTING: Integrator.Weightings - type of weighting (default = CONSTANT)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return number:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.BogaczEtAl">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">BogaczEtAl</code><span class="sig-paren">(</span><em>variable_default=[[0]], drift_rate: &lt;function parameter_spec at 0x10a6a5048&gt; = 1.0, starting_point: &lt;function parameter_spec at 0x10a6a5048&gt; = 0.0, threshold: &lt;function parameter_spec at 0x10a6a5048&gt; = 1.0, noise: &lt;function parameter_spec at 0x10a6a5048&gt; = 0.5, t0: &lt;function parameter_spec at 0x10a6a5048&gt; = 0.2, params=None, prefs: &lt;function is_pref_set at 0x109989488&gt; = None, context='Integrator Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BogaczEtAl" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute analytic solution to DDM process and return mean response time and accuracy.</p>
<dl class="docutils">
<dt>Description:</dt>
<dd><dl class="first last docutils">
<dt>generates mean response time (RT) and mean error rate (ER) as described in:</dt>
<dd>Bogacz, R., Brown, E., Moehlis, J., Holmes, P., &amp; Cohen, J. D. (2006). The physics of optimal
decision making: a formal analysis of models of performance in two-alternative forced-choice
tasks.  Psychological review, 113(4), 700. (<a class="reference external" href="https://www.ncbi.nlm.nih.gov/pubmed/17014301">PubMed entry</a>)</dd>
</dl>
</dd>
<dt>Initialization arguments:</dt>
<dd><p class="first">variable (float): set to self.value (== self.inputValue)
- params (dict):  runtime_params passed from Mechanism, used as one-time value for current execution:</p>
<blockquote>
<div><ul class="simple">
<li>drift_rate (DRIFT_RATE: float)</li>
<li>threshold (THRESHOLD: float)</li>
<li>bias (kwDDM_Bias: float)</li>
<li>noise (NOISE: float)</li>
<li>t0 (NON_DECISION_TIME: float)</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>time_scale (TimeScale): specifies &#8220;temporal granularity&#8221; with which mechanism is executed</li>
<li>context (str)</li>
</ul>
<dl class="last docutils">
<dt>Returns the following values in self.value (2D np.array) and in</dt>
<dd>the value of the corresponding outputState in the self.outputStates dict:
- decision variable (float)
- mean error rate (float)
- mean RT (float)
- correct mean RT (float) - Navarro and Fuss only
- correct mean ER (float) - Navarro and Fuss only</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="Function.BogaczEtAl.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BogaczEtAl.function" title="Permalink to this definition">¶</a></dt>
<dd><p>DDM function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="InputState.html#InputState.InputState.variable" title="InputState.InputState.variable"><strong>variable</strong></a> &#8211; (list)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
drift_rate...</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.NavarroAndFuss">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">NavarroAndFuss</code><span class="sig-paren">(</span><em>variable_default=[[0]], drift_rate: &lt;function parameter_spec at 0x10a6a5048&gt; = 1.0, starting_point: &lt;function parameter_spec at 0x10a6a5048&gt; = 0.0, threshold: &lt;function parameter_spec at 0x10a6a5048&gt; = 1.0, noise: &lt;function parameter_spec at 0x10a6a5048&gt; = 0.5, t0: &lt;function parameter_spec at 0x10a6a5048&gt; = 0.2, params=None, prefs: &lt;function is_pref_set at 0x109989488&gt; = None, context='Integrator Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.NavarroAndFuss" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute analytic solution to distribution of DDM responses (mean and variance of response time and accuracy).</p>
<dl class="docutils">
<dt>Description:</dt>
<dd><dl class="first last docutils">
<dt>generates distributions of response time (RT) and error rate (ER) as described in:</dt>
<dd>Navarro, D. J., and Fuss, I. G. &#8220;Fast and accurate calculations for first-passage times in
Wiener diffusion models.&#8221; Journal of Mathematical Psychology 53.4 (2009): 222-230.
(<a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S0022249609000200">ScienceDirect entry</a>)</dd>
</dl>
</dd>
<dt>Initialization arguments:</dt>
<dd><p class="first">variable (float): set to self.value (== self.inputValue)
- params (dict):  runtime_params passed from Mechanism, used as one-time value for current execution:</p>
<blockquote>
<div><ul class="simple">
<li>drift_rate (DRIFT_RATE: float)</li>
<li>threshold (THRESHOLD: float)</li>
<li>bias (kwDDM_Bias: float)</li>
<li>noise (NOISE: float)</li>
<li>t0 (NON_DECISION_TIME: float)</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>time_scale (TimeScale): specifies &#8220;temporal granularity&#8221; with which mechanism is executed</li>
<li>context (str)</li>
</ul>
<dl class="last docutils">
<dt>Returns the following values in self.value (2D np.array) and in</dt>
<dd>the value of the corresponding outputState in the self.outputStates dict:
- decision variable (float)
- mean error rate (float)
- mean RT (float)
- correct mean RT (float) - Navarro and Fuss only
- correct mean ER (float) - Navarro and Fuss only</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="Function.NavarroAndFuss.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.NavarroAndFuss.function" title="Permalink to this definition">¶</a></dt>
<dd><p>DDM function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="InputState.html#InputState.InputState.variable" title="InputState.InputState.variable"><strong>variable</strong></a> &#8211; (list)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
drift_rate...</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Reinforcement">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Reinforcement</code><span class="sig-paren">(</span><em>variable_default=[[0], [0], [0]], activation_function: &lt;typecheck.tc_predicates.any object at 0x10a67efd0&gt; = &lt;class 'Function.SoftMax'&gt;, learning_rate: &lt;function parameter_spec at 0x10a6a5048&gt; = 1, params=None, prefs: &lt;function is_pref_set at 0x109989488&gt; = None, context='Component Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Reinforcement" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate matrix of weight changes using the reinforcement (delta) learning rule</p>
<dl class="docutils">
<dt>Reinforcement learning rule</dt>
<dd>[matrix]         [scalar]        [col array]</dd>
<dt>delta_weight =  learning rate   *     error</dt>
<dd>return     =  LEARNING_RATE  *  self.variable</dd>
<dt>Reinforcement.function:</dt>
<dd><p class="first">variable must be a 1D np.array of error terms
assumes matrix to which errors are applied is the identity matrix</p>
<blockquote>
<div>(i.e., set of &#8220;parallel&#8221; weights from input to output)</div></blockquote>
<p class="last">LEARNING_RATE param must be a float
returns matrix of weight changes</p>
</dd>
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><p class="first">variable (list or np.array): must a single 1D np.array</p>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifies</dt>
<dd><ul class="first last simple">
<li>LEARNING_RATE: (float) - learning rate (default: 1.0)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="Function.Reinforcement.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Reinforcement.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a matrix of weight changes from a single (scalar) error term</p>
<p>Assume output array has a single non-zero value chosen by the softmax function of the error_source
Assume error is a single scalar value
Assume weight matrix (for MappingProjection to error_source) is a diagonal matrix</p>
<blockquote>
<div>(one weight for corresponding pairs of elements in the input and output arrays)</div></blockquote>
<p>Adjust the weight corresponding to the chosen element of the output array, using error value and learning rate</p>
<dl class="docutils">
<dt>Note: assume variable is a 2D np.array with three items (input, output, error)</dt>
<dd>for compatibility with other learning functions (and calls from LearningProjection)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="InputState.html#InputState.InputState.variable" title="InputState.InputState.variable"><strong>variable</strong></a> &#8211; 2D np.array with three items (input array, output array, error array)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entry specifying:
LEARNING_RATE: (float) - (default: 1)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return matrix:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.BackPropagation">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">BackPropagation</code><span class="sig-paren">(</span><em>variable_default=[[0], [0], [0]], activation_function: &lt;typecheck.tc_predicates.any object at 0x10a6735f8&gt; = &lt;class 'Function.Logistic'&gt;, learning_rate: &lt;function parameter_spec at 0x10a6a5048&gt; = 1, params=None, prefs: &lt;function is_pref_set at 0x109989488&gt; = None, context='Component Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BackPropagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate matrix of weight changes using the backpropagation (Generalized Delta Rule) learning algorithm</p>
<dl class="docutils">
<dt>Backpropagation learning algorithm (Generalized Delta Rule):</dt>
<dd>[matrix]         [scalar]       [row array]              [row array/ col array]                 [col array]</dd>
<dt>delta_weight =  learning rate   *    input      *            d(output)/d(input)                 *     error</dt>
<dd>return     =  LEARNING_RATE  *  variable[0]  *  kwTransferFctDeriv(variable[1],variable[0])  *  variable[2]</dd>
<dt>BackPropagation.function:</dt>
<dd><dl class="first docutils">
<dt>variable must be a list or np.array with three items:</dt>
<dd><ul class="first last simple">
<li>input (e.g, array of activities of sender units)</li>
<li>output (array of activities of receiver units)</li>
<li>error (array of errors for receiver units)</li>
</ul>
</dd>
</dl>
<p class="last">LEARNING_RATE param must be a float
kwTransferFunctionDerivative param must be a function reference for dReceiver/dSender
returns matrix of weight changes</p>
</dd>
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><p class="first">variable (list or np.array): must have three 1D elements</p>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifies</dt>
<dd><ul class="first last simple">
<li>LEARNING_RATE: (float) - learning rate (default: 1.0)</li>
<li>kwTransferFunctionDerivative - (function) derivative of TransferMechanism function (default: derivative of logistic)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="Function.BackPropagation.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BackPropagation.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and return a matrix of weight changes from an array of inputs, outputs and error terms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="InputState.html#InputState.InputState.variable" title="InputState.InputState.variable"><strong>variable</strong></a> &#8211; (list or np.array) len = 3 (input, output, error)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; <p>(dict) with entries specifying:
LEARNING_RATE: (float) - (default: 1)
kwTransferFunctionDerivative (function) - derivative of function that generated values</p>
<blockquote>
<div>(default: derivative of logistic function)</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return number:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Run.html" class="btn btn-neutral float-right" title="Run" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="LearningProjection.html" class="btn btn-neutral" title="LearningProjection" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Jonathan D. Cohen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>